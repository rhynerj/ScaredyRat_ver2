"""
Functions to launch and run GUI for Scaredy Rat.
"""
# imports
import math
import PySimpleGUI as sg

import src.sr_functions as srf
import src.sr_individual as sri
import src.sr_compiled as srco
import src.sr_settings as srs


################################################################################################
# Functions
################################################################################################
def print_help(help_key):
    """
    Set up help menu behavior, appearance, and options
    """
    help_dict = {
        'SheetNameHelp': 'Comma-separated list of sheet names which were generated by EthoVision.',
        'DetLblHelp': 'Comma-separated list of trial control settings labels, that were set in EthoVision.',
        'TrialTypeHelp': 'Comma-separated list of trial type names (in common language), matched in order to the trial control settings labels. These are used in plot titles.',
        'TrialTypeABRHelp': 'Abbreviated names for the trial types, matched in order.  These are used in filenames.',
        'EpochCountHelp': 'The number of epochs per trial type.  This is a comma-separated list matched in order to the trial control labels. Sub-epochs will be defined relative to these epochs in another menu.',
        'TimeHelp': 'Size of each time bin, in seconds. The minimum effective binSize is limited by the sampling frequency of the recorded data.',
        'baselineHelp': 'Length of time (from trial start to this number of time bins) to use as the behavioural baseline.',
        'FreezeTHelp': 'The velocity below which the animal is considered freezing (velocity is averaged for each time bin, as defined by binSzie).  This needs to be in the same units as the behavioral recording software output (e.g. cm/s).',
        'dartTHelp': 'The velocity above which the animal is considered to have darted (velocity is averaged for each time bin, as defined by binSzie).  This needs to be in the same units as the behavioral recording software output (e.g. cm/s).',
        'EpochHelp': 'The list of epochs, defined in EthoVision.',
        'dEpochHelp': 'The derived epochs are based on the times defined by the epochs. The list is a comma-seperated list of epoch names, defined by the user.The epoch-based time offset (in seconds) each derived epoch is in the format: [start_index, start_offset, stop_offset, plot_flag].\n\n  - start_index is the epoch index in which the derived epoch started (e.g. 0 would be the start of the epoch, 1 would be the next bin in the epoch, and -1 would skip straight to the end of the epoch).\n\n  - start_offset is the time (in time bins) from the starting index (e.g. -30 would start the derived epoch 30 time steps prior to the epoch start). This number is added to or subtracted from the time identified by start_index.\n\n  - stop_offset is the time (in time bins) from the starting index to end the derived epoch (e.g. 25 would end the derived epoch 25 time steps after the starting index). This number is added to or subtracted from the time identified by start_index.\n\n  - plot_flag is either [True] or [False], and determines whether the derived epoch should (True) or should not (False) be plotted in the velocity plot when ScaredyRat is run.',
    }
    help_text = help_dict[help_key]

    help_layout = [[sg.Text(help_text, size=(90, None))],
                   [sg.Button('Close')]]
    help_window = sg.Window('Help Window', help_layout)

    while True:
        help_event, help_vals = help_window.read()
        if help_event == sg.WIN_CLOSED or help_event == 'Close':  # if user closes window or clicks cancel
            help_window.close()
            break
    help_window.close()


def make_main_window(in_out_settings):
    """
    Set up and return the main window.
    """
    # Setup menu layouts
    layout_main = [[sg.Text('Main Window.\nUse buttons to navigate ScaredyRat settings')],
                   [sg.Button('Select Input Folder'), sg.Text(in_out_settings.inpath, key='INDIR', size=(64, 1))],
                   # , sg.Text(inpath, key='INDIR', size=(64,1))
                   [sg.Button('Select Individual Animal Output Folder'),
                    sg.Text(in_out_settings.ind_outpath, key='OUTDIR', size=(64, 1))],
                   # , sg.Text(outpath, key='OUTDIR', size=(64,1))
                   [sg.Button('Select Compiled Output Folder'),
                    sg.Text(in_out_settings.com_outpath, key='OUTDIR2', size=(64, 1))],
                   # , sg.Text(outpath2, key='OUTDIR2', size=(64,1))
                   [sg.Button('Sheet Settings')],
                   [sg.Button('Trial Settings')],
                   [sg.Button('Epoch and Derived Epoch Settings')],
                   [sg.Button('View Settings')],
                   [sg.Text('')],
                   [sg.Button('Run'),
                    sg.CBox('Run Full Velocity Analysis', pad=(20, 0), default=in_out_settings.full_vel,
                            key='FullAnalysis', enable_events=True)],
                   [sg.Button('Compile Only')],
                   [sg.Text('')],
                   [sg.Button('Exit')]]
    return sg.Window('ScaredyRat', layout_main)


def setting_to_string(setting):
    """
    Stringify the given setting
    """
    if isinstance(setting, list):
        if len(setting) == 0:
            return ''
        setting_str = ','.join(str(s) for s in setting)
        return setting_str
    else:
        return str(setting)


def make_sheet_window(sheet_list, detection_labels, trial_type_fulls, trial_type_abbrs):
    """
    Set up and return the sheet settings window.
    """
    sheet_col = [
        [sg.Text('List of sheet names', size=(40, 1)), sg.Multiline(setting_to_string(sheet_list), size=(None, 2)),
         sg.Button('Help', key='SheetNameHelp')],
        [sg.Text('Trail Control Settings Labels', size=(40, 1)),
         sg.Multiline(setting_to_string(detection_labels), size=(None, 1)),
         sg.Button('Help', key='DetLblHelp')],
        [sg.Text('Trial Type List', size=(40, 1)),
         sg.Multiline(setting_to_string(trial_type_fulls), size=(None, 1)),
         sg.Button('Help', key='TrialTypeHelp')],
        [sg.Text('Trial Type Abbreviation List', size=(40, 1)),
         sg.Multiline(setting_to_string(trial_type_abbrs), size=(None, 1)), sg.Button('Help', key='TrialTypeABRHelp')]
    ]
    layout_sheet = [[sg.Text('Sheet Information')],
                    [sg.Column(sheet_col)],
                    [sg.Button('Apply'), sg.Button('Ok'), sg.Button('Cancel')]]

    return sg.Window('Sheet Settings', layout_sheet)


def run_sheet_window(sheet_window, sheet_settings, epoch_settings):
    """
    Handle events for sheet_window, updating sheet and epoch settings if 'Apply' or 'Ok' selected.
    Return sheet and epoch settings, with updates if there were any.
    """
    # event loop to process "events" and get the "values" of the inputs
    while True:
        sheet_event, sheet_values = sheet_window.read()
        print("\nsheet event:", sheet_event, "sheet values:", sheet_values, sep="\n")

        if sheet_event == sg.WIN_CLOSED or sheet_event == 'Cancel':  # if user closes window or clicks cancel
            sheet_window.close()
            break
        if sheet_event == 'Apply':  # if user clicks apply
            # note: raw_sheet_settings are sheet window values (which is why run_sheet_window doesn't take them as arg)
            sheet_settings, epoch_settings = srs.SheetSettings.settings_from_dict(sheet_values, epoch_settings)
        if sheet_event == 'Ok':  # if user clicks ok -> similar to apply, but also closes window
            sheet_settings, epoch_settings = srs.SheetSettings.settings_from_dict(sheet_values, epoch_settings)
            sheet_window.close()
            break
        if sheet_event == 'SheetNameHelp':
            print_help(sheet_event)
        if sheet_event == 'DetLblHelp':
            print_help(sheet_event)
        if sheet_event == 'TrialTypeHelp':
            print_help(sheet_event)
        if sheet_event == 'TrialTypeABRHelp':
            print_help(sheet_event)

    # close window
    sheet_window.close()

    # return updated settings
    return sheet_settings, epoch_settings


def make_trial_window(trial_settings):
    """
    Set up and return the trial settings window.
    """
    trial_col = [
        [sg.Text('Time Bin Duration (s)', size=(15, 1)), sg.Input(trial_settings.bin_secs, size=(20, 1)),
         sg.Button('Help', key='TimeHelp')],
        [sg.Text('Baseline Duration (# time bins)', size=(15, 1)),
         sg.Input(trial_settings.baseline_duration, size=(20, 1)),
         sg.Button('Help', key='baselineHelp')],
        [sg.Text('Freezing Threshold (velocity units)', size=(15, 1)),
         sg.Input(trial_settings.freeze_thresh, size=(20, 1)),
         sg.Button('Help', key='FreezeTHelp')],
        [sg.Text('Darting Threshold (velocity units)', size=(15, 1)),
         sg.Input(trial_settings.dart_thresh, size=(20, 1)),
         sg.Button('Help', key='dartTHelp')],
    ]
    layout_trial = [[sg.Text('Trial Information')],
                    [sg.Column(trial_col)],
                    [sg.Button('Apply'), sg.Button('Ok'), sg.Button('Cancel')]]
    return sg.Window('Trial Settings', layout_trial)


def run_trial_window(trial_window, trial_settings):
    """
    Handle events for trial_window, updating trial settings if 'Apply' or 'Ok' selected.
    Return trial settings, with updates if there were any.
    """
    # event loop to process "events" and get the "values" of the inputs
    while True:
        trial_event, trial_values = trial_window.read()
        if trial_event == sg.WIN_CLOSED or trial_event == 'Cancel':  # if user closes window or clicks cancel
            trial_window.close()
            break
        if trial_event == 'Apply':  # if user clicks apply
            trial_settings = srs.TrialSettings.trial_from_dict(trial_values)
        if trial_event == 'Ok':  # if user clicks ok
            trial_settings = srs.TrialSettings.trial_from_dict(trial_values)
            trial_window.close()
            break
        # this should be if trial_event in ['TimeHelp', baselineHelp, etc]
        if trial_event == 'TimeHelp':
            print_help(trial_event)
        if trial_event == 'baselineHelp':
            print_help(trial_event)
        if trial_event == 'FreezeTHelp':
            print_help(trial_event)
        if trial_event == 'dartTHelp':
            print_help(trial_event)

    # close window
    trial_window.close()

    # return updated settings
    return trial_settings


def get_detection_label_and_epoch(detection_settings_labels, epoch_settings, epoch_values, case):
    """
    Return appropriate detection settings label and Epoch for specified case.
    """
    # based on case, set vars
    # 0 = initial set-up, 1 = epoch added, 2 = epoch deleted, 3 = drop down selection
    if case == 0:
        # default to first items upon initial window launch
        detection_label = detection_settings_labels[0]
        selected_epoch = epoch_settings[detection_label][0]
    else:
        # for all other cases, detection label is selected
        detection_label = epoch_values['TrialSelectDropdown']
        # added epoch case -> display added epoch
        if case == 1:
            # !note: that this relies on the new epoch having been added first
            selected_epoch = epoch_settings.get_epoch_by_label(detection_label, epoch_values['NewEpoch'])
            # throw exception if epoch hasn't been added correctly for some reason
            if selected_epoch is None:
                raise KeyError('Specified detection settings and epoch label combination does not exist in Settings.')
        # deleted epoch case -> make empty epoch for selected
        elif case == 2:
            selected_epoch = srs.Epoch('', '', '', {})
        # case where trial type (detection settings) or epoch was selected from dropdown
        elif case == 3:
            selected_epoch = epoch_settings.get_epoch_by_label(detection_label, epoch_values['EpochSelectDropdown'])

    return detection_label, selected_epoch


def sub_epoch_time_entry(sub_epoch_label, sub_epoch_times):
    """
    Return GUI list item for given sub_epoch, with label and times input field.
    """
    return [sg.Text(sub_epoch_label, size=(20, 1)),
            sg.Input(sub_epoch_times, size=(40, 1), key=sub_epoch_label)]


def make_epoch_window(detection_settings_labels, epoch_settings, epoch_values=None, case=0):
    """
    Set up and return the epoch settings window.
    Note: this function is intended both for initial set up and to be rerun to reflect state changes.
    """
    # case is an int that indicates what to use vals to autofill fields:
    # 'TrialSelectDropdown', 'EpochSelectDropdown', 'nEpochs', 'dEpoch_list', derived epoch timing

    # get the appropriate detection label and selected epoch
    detection_label, selected_epoch = get_detection_label_and_epoch(detection_settings_labels, epoch_settings,
                                                                    epoch_values, case)

    # possible epoch labels for current detection label
    epoch_options = [epoch.label for epoch in epoch_settings[detection_label]]

    epoch_col = [
                    [sg.Text('Trial Type'),
                     sg.Combo(detection_settings_labels, default_value=detection_label,
                              enable_events=True, key='TrialSelectDropdown')],
                    [sg.Text('New epoch base label', size=(20, 1)),
                     sg.Input('', size=(40, 1), key='NewEpoch'),
                     sg.CBox('Space Present', pad=(20, 0), default=True, key='UseSpace'),
                     sg.Button('Add Epoch Label', key='AddEpoch'), sg.Button('Help', key='EpochHelp')],
                    [sg.Text('Epoch base Label'),
                     sg.Combo(epoch_options, default_value=selected_epoch.label,
                              enable_events=True, key='EpochSelectDropdown'),
                     sg.Button('Delete This Epoch', key='DelEpoch')],
                    [sg.Text('')],
                    [sg.Text('Number of epochs per trial', size=(40, 1)),
                     sg.Input(str(selected_epoch.epoch_count), size=(40, 1),
                              key='nEpochs'),
                     sg.Button('Help', key='EpochCountHelp')],
                    [sg.Text('Derived Epoch List', size=(20, 1)), sg.Input(','.join(selected_epoch.sub_epochs),
                                                                           size=(40, 1), key='dEpoch_list'),
                     sg.Button('Help', key='dEpochHelp')],
                    [sg.Text('Derived Epoch Timing:')],
                    # [sg.Text('')] ] + [dEpochTimeEntry(derivedEpoch_list[trialID_epochMenu][iter],derivedEpochTiming_list[trialID_epochMenu][iter]) for iter in range(0,len(derivedEpoch_list[trialID_epochMenu]))]
                    [sg.Text('')]] + [sub_epoch_time_entry(sub_epoch_label, sub_epoch_times)
                                      for sub_epoch_label, sub_epoch_times in
                                      selected_epoch.sub_epochs.items()]

    layout_epoch = [[sg.Text('Epoch Information')],
                    [sg.Column(epoch_col)],
                    [sg.Button('Apply'), sg.Button('Ok'), sg.Button('Cancel')]]

    return sg.Window('Epoch Settings (Click Apply to update the derived epoch timing list)',
                     layout_epoch)


def add_epoch(epoch_window, epoch_values, detection_settings_labels, epoch_settings):
    """
    Add inputted epoch to Epoch settings and update epoch settings window.
    Return updated window and settings.
    """
    # add to epoch_settings dict
    # create new Epoch object with values from fields -> init with epoch_count as 1 and empty dict for sub_epochs
    # note: old version had sub_epoch default as {'': ''}
    new_epoch = srs.Epoch(epoch_values['NewEpoch'], epoch_values['UseSpace'], 1, {})
    # append new Epoch to current detection label's list
    epoch_settings[epoch_values['TrialSelectDropdown']].append(new_epoch)

    # close old window
    epoch_window.close()
    # make new window -> call make_epoch_window() w/ case = 1 (which means autofill from entered vals)
    epoch_window = make_epoch_window(detection_settings_labels, epoch_settings, epoch_values=epoch_values, case=1)

    # return updated window and epoch settings
    return epoch_window, epoch_settings


def delete_epoch(epoch_window, epoch_values, detection_settings_labels, epoch_settings):
    """
    Deleted selected epoch from Epoch settings and update epoch settings window.
    Return updated window and settings.
    """
    # delete selected epoch from epoch_settings for selected detection settings
    epoch_settings[epoch_values['TrialSelectDropdown']] = [epoch for epoch
                                                           in epoch_settings[epoch_values['TrialSelectDropdown']]
                                                           if epoch.label != epoch_values['EpochSelectDropdown']]

    # close old window
    epoch_window.close()
    # make new window -> call make_epoch_window() w/ case = 2 (empty default vals, but not dropdowns)
    epoch_window = make_epoch_window(detection_settings_labels, epoch_settings, epoch_values=epoch_values, case=2)

    # return updated window and epoch settings
    return epoch_window, epoch_settings


def update_epoch_settings(epoch_values, epoch_settings):
    """
    Update epoch count and derived epoch settings for epoch settings of selected epoch.
    Return updated epoch settings.
    """
    # note: this fn updates the sub_epochs field dict

    # get selected epoch
    curr_epoch = epoch_settings.get_epoch_by_label(epoch_values['TrialSelectDropdown'],
                                                   epoch_values['EpochSelectDropdown'])

    # update epoch count
    curr_epoch.epoch_count = epoch_values['nEpochs']

    # new sub_epoch list
    new_sub_epochs = [sub_epoch.strip() for sub_epoch in epoch_values['dEpoch_list'].split(',')]
    # update sub_epochs to new dict
    curr_epoch.sub_epochs = {sub_epoch: epoch_values.get(sub_epoch, '').strip() for sub_epoch in new_sub_epochs}

    return epoch_settings


def run_epoch_window(epoch_window, detection_labels, epoch_settings):
    """
    Handle events for epoch_window, adding/deleting epochs; allowing selection of specific epochs;
    and updating epoch settings if 'Apply' or 'Ok' selected.
    Return epoch settings, with updates if there were any.
    """
    # event loop to process "events" and get the "values" of the inputs
    while True:
        epoch_event, epoch_values = epoch_window.read()
        print('\nepoch event', epoch_event, 'epoch values', epoch_values)

        if epoch_event == sg.WIN_CLOSED or epoch_event == 'Cancel':  # if user closes window or clicks cancel
            break

        if epoch_event == 'AddEpoch':
            # update and reload window, update epoch settings to include new epoch
            epoch_window, epoch_settings = add_epoch(epoch_window, epoch_values, detection_labels,
                                                     epoch_settings)
        if epoch_event == 'DelEpoch':
            # update and reload window, update epoch settings to omit deleted epoch
            epoch_window, epoch_settings = delete_epoch(epoch_window, epoch_values, detection_labels,
                                                        epoch_settings)

        if epoch_event == 'EpochSelectDropdown':
            epoch_window.close()  # close old window, open new (w/ make)
            # call make_epoch_window() w/ case = 3 (get field vals for selected trial and epoch)
            epoch_window = make_epoch_window(detection_labels, epoch_settings,
                                             epoch_values=epoch_values, case=3)

        if epoch_event == 'TrialSelectDropdown':
            epoch_window.close()  # close old window, open new (w/ make)
            # call make_epoch_window() w/ case = 3 (get field vals for selected trial and epoch)
            epoch_window = make_epoch_window(detection_labels, epoch_settings,
                                             epoch_values=epoch_values, case=3)

        if epoch_event == 'Ok':  # if user clicks Ok
            # update epoch settings for selected epoch
            epoch_settings = update_epoch_settings(epoch_values, epoch_settings)

            break

        if epoch_event == 'Apply':  # if user clicks Apply to update the window
            # update epoch settings for selected epoch
            epoch_settings = update_epoch_settings(epoch_values, epoch_settings)

            epoch_window.close()  # close old window, open new (w/ make)
            # call make_epoch_window() w/ case = 3 (which just updates based on current values)
            epoch_window = make_epoch_window(detection_labels, epoch_settings,
                                             epoch_values=epoch_values, case=3)

        if epoch_event == 'EpochHelp':
            print_help(epoch_event)
        if epoch_event == 'dEpochHelp':
            print_help(epoch_event)
        if epoch_event == 'dEpochTimeHelp':
            print_help(epoch_event)
        if epoch_event == 'EpochCountHelp':
            print_help(epoch_event)

    # close window
    epoch_window.close()

    # return updated settings
    return epoch_settings


def print_settings(in_out_settings, sheet_settings, trial_settings, epoch_settings):
    """
    Print given settings.
    """
    print('\n\ninput/output settings:', in_out_settings)
    print('sheet settings:', sheet_settings)
    print('trial settings:', trial_settings)
    print('epoch settings:', epoch_settings)


def run_SR(in_out_settings=srs.InOutSettings(), sheet_settings=srs.SheetSettings(), trial_settings=srs.TrialSettings(),
           epoch_settings=srs.EpochSettings()):
    """
    Run analysis for both individual animals and compiled across all animals.
    Output CSVs and plots.
    """
    # input and output paths
    inpath = in_out_settings.inpath
    outpath = in_out_settings.ind_outpath
    full_analysis = in_out_settings.full_vel

    # get list of input files
    filelist = sri.get_file_list(inpath)

    # set up layout for progress bar
    layout_prog = [[sg.ProgressBar(max_value=4 * len(filelist), orientation='horizontal', size=(20, 10), style='clam',
                                   key='SR_PROG')],
                   [sg.Cancel()]]

    # initialize sheets processed count to 0
    sheet_ct = 0

    # add progress window
    prog_window = sg.Window('ScaredyRat', layout_prog)
    prog_bar = prog_window['SR_PROG']

    # iterate over list of files (from input folder)
    for file in filelist:
        # iterate over the sheets in the given sheetlist
        # (note that these are manually provided, not automatically extracted
        for sheet in sheet_settings.sheet_list:
            # increment count by one
            sheet_ct += 1

            # get stuff from the progress bar -> not 100% sure what this is doing
            prog_event, prog_values = prog_window.read(timeout=1)
            # handle closing events
            if prog_event == 'Cancel' or prog_event == sg.WIN_CLOSED:
                break
            # update progress bar according to current count
            prog_bar.update(sheet_ct)

            # get data from current sheet
            anim_id, ctx, anim = srf.animal_read(inpath, file, sheet)
            print('\nEvaluating ' + sheet + ' in the file ' + file)

            # check the context, skipping if the file isn't an Excel sheet or isn't properly labeled
            if (anim_id == "-1" or anim_id == "nan"
                    or (isinstance(anim_id, float) and math.isnan(float(anim_id)))
                    or (isinstance(anim_id, int) and anim_id == -1)):
                print('\nAnimal Detection Failure: failed to load sheet or animal ID not found',
                      anim_id, '\n', ctx, sep='\n')
                continue
            else:
                # get epochs, trial_type_key, trial_type_full, trial_type_abbr or false if error
                trial_info = sri.get_trial_info(ctx, sheet_settings, epoch_settings)
                if trial_info:
                    # extract vars from results
                    epochs, trial_type_key, trial_type_full, trial_type_abbr = trial_info
                else:
                    continue

            # output baseline data csv
            sri.baseline_data_out(anim_id, anim, outpath, trial_settings.bin_secs, trial_settings.baseline_duration,
                                  trial_settings.freeze_thresh, trial_settings.dart_thresh, trial_type_abbr)

            # output analysis files for given animal, for each epoch and subepoch
            sri.all_epoch_analysis(anim, anim_id, outpath, trial_type_full, trial_type_abbr, epochs,
                                   trial_settings.freeze_thresh, trial_settings.dart_thresh,
                                   trial_settings.bin_secs, full_analysis)

    # compiled_output function
    srco.compiled_output(in_out_settings, sheet_settings, epoch_settings)

    # close progress window
    prog_window.close()


def run_main_window(main_window, in_out_settings, sheet_settings, trial_settings, epoch_settings):
    """
    Handle events for main_window:
    - set input/output settings
    - launch settings windows
    - run analysis
    """
    # event loop to process "events" and get the "values" in the main window
    while True:
        main_event, main_values = main_window.read()
        if main_event == sg.WIN_CLOSED or main_event == 'Exit':  # if user closes window or clicks cancel
            break
        elif main_event == 'FullAnalysis':
            # toggle full velocity analysis
            in_out_settings.full_vel = not in_out_settings.full_vel
            main_window['FullAnalysis'].update(in_out_settings.full_vel)
        elif main_event == 'Select Input Folder':
            in_out_settings.inpath = sg.popup_get_folder(
                'Please select the directory from which to load the Ethovision-style data',
                initial_folder=in_out_settings.inpath)
            main_window['INDIR'].update(
                in_out_settings.inpath)  # should be no need to cast to string; but add back if things break
        elif main_event == 'Select Individual Animal Output Folder':
            in_out_settings.ind_outpath = sg.popup_get_folder(
                'Please select the directory in which to output the individual data files',
                initial_folder=in_out_settings.ind_outpath)
            main_window['OUTDIR'].update(in_out_settings.ind_outpath)
        elif main_event == 'Select Compiled Output Folder':
            in_out_settings.com_outpath = sg.popup_get_folder(
                'Please select the directory in which to output the compiled files',
                initial_folder=in_out_settings.com_outpath)
            main_window['OUTDIR2'].update(in_out_settings.com_outpath)
        elif main_event == 'Sheet Settings':
            # get individual components from sheet settings
            sheet_list, detection_labels, trial_type_fulls, trial_type_abbrs = sheet_settings.disintegrate_sheet_settings()

            # make sheet window object
            sheet_window = make_sheet_window(sheet_list, detection_labels, trial_type_fulls, trial_type_abbrs)

            # handle events in sheet window, update sheet and epoch settings accordingly
            sheet_settings, epoch_settings = run_sheet_window(sheet_window, sheet_settings, epoch_settings)

        elif main_event == 'Trial Settings':
            # make trial window object
            trial_window = make_trial_window(trial_settings)

            # handle events in trial window, update trial settings accordingly
            trial_settings = run_trial_window(trial_window, trial_settings)

        elif main_event == 'Epoch and Derived Epoch Settings':
            # get current list of detection settings labels
            detection_labels = sheet_settings.disintegrate_sheet_settings()[1]

            # make epoch window object
            epoch_window = make_epoch_window(detection_labels, epoch_settings, case=0)

            # handle events in epoch window, update epoch settings accordingly
            epoch_settings = run_epoch_window(epoch_window, detection_labels,
                                              epoch_settings)  # note: detection_labels retrieved for use in making window

        elif main_event == 'View Settings':
            # just prints settings (representations based on __str__ methods)
            print_settings(in_out_settings, sheet_settings, trial_settings, epoch_settings)

        elif main_event == 'Run':
            # print current settings
            # print('', sheet_settings, trial_settings, epoch_settings, sep='\n\n')
            print_settings(in_out_settings, sheet_settings, trial_settings, epoch_settings)

            # run ScaredyRat with current settings -> note: run_SR will be moving back to SR_GUI.py
            run_SR(in_out_settings, sheet_settings, trial_settings, epoch_settings)

            # finish notification
            sg.popup('ScaredyRat Complete')

        elif main_event == 'Compile Only':
            # run compiled_output fn with current settings
            srco.compiled_output(in_out_settings, sheet_settings, epoch_settings)

            # finish notification
            sg.popup('Compile Complete')

    # close window
    main_window.close()


################################################################################################
# Execution
################################################################################################

def main():
    """
    Main function to initialize settings objects and launch and run main window.
    """
    # set theme
    sg.theme('Light Green 3')
    sg.set_options(font='Arial 14')

    # init default settings objects
    in_out_settings = srs.InOutSettings()
    sheet_settings = srs.SheetSettings()
    trial_settings = srs.TrialSettings()
    epoch_settings = srs.EpochSettings()

    # make main window object
    main_window = make_main_window(in_out_settings)

    # print 20 blank lines
    print('\n' * 20)

    # handle events in main window, internally updating settings accordingly
    # doesn't return anything because program quits when main window is closed
    run_main_window(main_window, in_out_settings, sheet_settings, trial_settings, epoch_settings)


# below will be replaced with main()
if __name__ == '__main__':
    main()
